/**
 * The code in this class works with the following instances:
 * INPUT query file must have regular edges, and edges connecting intermediate nodes must be replaced with property with > 30000 id.
 * INPUT query log must be generated by replacing intermediate node edges by corresponding new edge ids.
 * The nodes in input query can be entities or type nodes.
 *
 * If we want this to work for queries where type nodes are considered, but without having new edges for intermediate node edges, THEN:
 * - we must keep the intermediateNodeList data structure empty. so we must comment out the line that populates it, lfm.loadIntermediateNodesList.
 * - also comment out the lfm.loadConcatedPropertiesList() function call. no need for this.
 * ****IMP***** THE ABOVE TWO CAN BE ACHIEVED by setting the "QuerySuggestion.ConcatenateIntermediatNodeEdges" flag to 0 in prop file. *******IMP********
 * - BUT, we will ALSO NEED the query log to be generated without replacing intermediate node edges with new edge IDs.
 *
 *  INPUT FILES:
 *  PropertyKeys.datagraphFile: data graph file
 *  PropertyKeys.edgeTypeFile: file containing the type of edge ends
 *  PropertyKeys.intermediateNodesFile: file containing list of intermediate nodes
 *  PropertyKeys.trainigDataWithIDFile: This is the USER LOG. Make sure this is the correct format user log you are using (no concat, or no newProp etc.)
 *
 */
package viiq.graphQuerySuggestionMain;

import it.unimi.dsi.lang.MutableString;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;

import org.apache.commons.configuration.ConfigurationException;
import org.apache.log4j.Level;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;

import viiq.commons.DataGraphGenerator;
import viiq.commons.EdgeEnds;
import viiq.commons.EdgeTypeInfo;
import viiq.commons.IntermediateNodeAndOtherEnd;
import viiq.commons.ObjNodeIntProperty;
import viiq.decisionForest.DecisionForestMain;
import viiq.otherClassifiers.naiveBayesian.NaiveBayesianMain;
import viiq.otherClassifiers.randomEdgeSuggestion.RandomEdgeSuggestor;
import viiq.otherClassifiers.randomForest.RandomForestPredict;
import viiq.otherClassifiers.randomSubsets.RandomSubsetsMain;
import viiq.otherClassifiers.svd.RecommendationSystem;
import viiq.utils.BufferedRandomAccessFile;
import viiq.utils.LoadFilesToMemory;
import viiq.utils.PropertyKeys;

public class GraphTypeQuerySuggestion {
	Config conf = null;
//	final Logger logger = Logger.getLogger(getClass());

	boolean isFreebaseDataset = false;

	HashMap<Integer, ArrayList<ObjNodeIntProperty>> srcDataGraph = new HashMap<Integer, ArrayList<ObjNodeIntProperty>>();
	HashMap<Integer, ArrayList<ObjNodeIntProperty>> objDataGraph = new HashMap<Integer, ArrayList<ObjNodeIntProperty>>();

	// store the type of the two ends of an edge.
	// key = edge, value = (source vertex Type, dest vertex Type)
	HashMap<Integer, EdgeTypeInfo> edgeType = new HashMap<Integer, EdgeTypeInfo>();
	// store all the types associated with an node/entity/vertex. The types are derived as the union of the type associated with this node
	// on all the edges it is incident on.
	// key = vertex ID, value = set of all types of this vertex
	//TIntObjectHashMap<TIntHashSet> abc = new TIntObjectHashMap<>();
	HashMap<Integer, HashSet<Integer>> nodeTypes = new HashMap<Integer, HashSet<Integer>>();
	//HashMap<Integer, HashSet<Integer>> nodeTypes = new HashMap<Integer, HashSet<Integer>>();
	// Edges associated with each node type.
	// when this node type is of source.
	// key = source Type, value = set of all edges that have the key as source type
	HashMap<Integer, HashSet<Integer>> srcTypeEdges = new HashMap<Integer, HashSet<Integer>>();
	// when this node type is of object.
	// key = object Type, value = set of all edges that have the key as object type
	HashMap<Integer, HashSet<Integer>> objTypeEdges = new HashMap<Integer, HashSet<Integer>>();
	// a node can be of multiple types. but the ends of an edge is of one specific type each. the neighboring edges associated with a node type
	// is not just the edges that are incident on this particular node type, but are those associated with other types that an instance of
	// this node type may have incident on them.
	// for example a node type "Founder" may also have edges that are incident on "Person" too, since every "Founder" will be a "Person" too.
	// key = node type, value = (other node types that instances of the "key" belong to)
	HashMap<Integer, HashSet<Integer>> invertedNodeTypes = new HashMap<Integer, HashSet<Integer>>();

	// set of nodes in the graph that are intermediate nodes.
	HashSet<Integer> intermediateNodesList = new HashSet<Integer>();
	// all types associated with intermediate nodes.
//	HashSet<Integer> intermediateNodesTypeList = new HashSet<Integer>();
	// key = concatenation of two edges connecting an intermediate node, value = new edge ID corresponding to the key
	HashMap<String, Integer> concatenatedEdgesToNewEdgeIdMap = new HashMap<String, Integer>();

	BufferedRandomAccessFile sourceDataGraphFileHandler;
	BufferedRandomAccessFile objectDataGraphFileHandler;
	int numOfTotalEdges = 0;
    //0 = DecisionForest;	1 = Random Forests;	2 = Naive Bayesian model;	3 = Random edge suggestion;
	//4 = recommendation systems (SVD);	5 = RandomSubsets;	6 = SVM;	7 = MEMM model;
	enum ModelToUseForType {DF, RF, NBC, RAND, SVD, RandSubsets, SVM, MEMM};
	ModelToUseForType model;

	boolean ignoreNegativeEdgesInHistory = false;
	boolean concatenateIntermediatNodeEdges = true;

	/*
	 * Model objects that can be used!
	 */
	NaiveBayesianMain nbc;
	RandomSubsetsMain rsm;
	DecisionForestMain dfm;
	RandomEdgeSuggestor res;
	RecommendationSystem svd;
	RandomForestPredict rfp;
	//MEMMMain memm;
	//SVM svm;

	GraphQuerySuggestionHelper gqhelper = new GraphQuerySuggestionHelper();

	public static void main(String[] args) {

		GraphTypeQuerySuggestion gqs = new GraphTypeQuerySuggestion();
		//gqs.logger = Logger.getRootLogger();
		//gqs.logger.setLevel(Level.OFF);
		List<Logger> loggers = Collections.<Logger>list(LogManager.getCurrentLoggers());
		loggers.add(LogManager.getRootLogger());
		for ( Logger logger : loggers ) {
		    logger.setLevel(Level.OFF);
		}

		if(args.length < 1)	{
			System.out.println("Need an input properties file! Exiting program...");
//			gqs.logger.error("Need an input properties file! Exiting program...");
			return;
		}
		else{
			try	{
				gqs.conf = new Config(args[0]);
			}
			catch(ConfigurationException ce){
				System.out.println("Error in properties file configuration! Exiting program...");
//				gqs.logger.error("Error in properties file configuration! Exiting program...");
				ce.printStackTrace();
				return;
			}
			catch(IOException ioe){
				System.out.println("IO exception while reading the properties file! Exiting program...");
//				gqs.logger.error("IO exception while reading the properties file! Exiting program...");
				ioe.printStackTrace();
				return;
			}
		}

		if(Integer.parseInt(gqs.conf.getProp(PropertyKeys.concatenateIntermediatNodeEdges)) == 0)
			gqs.concatenateIntermediatNodeEdges = false;
		gqs.loadEdgeTypeInfo();
		DataGraphGenerator dg = new DataGraphGenerator();
		LoadFilesToMemory lfm = new LoadFilesToMemory();
		System.out.println("starting to load the data graph");
		String dataGraphFilePath = gqs.conf.getInputFilePath(PropertyKeys.datagraphFile);
		if(gqs.isFreebaseDataset) {
			boolean loadDataGraph = false;
			if(Integer.parseInt(gqs.conf.getProp(PropertyKeys.loadDataGraphFlag)) == 1)
				loadDataGraph = true;
			gqs.numOfTotalEdges = dg.loadDataGraphIntProperty(dataGraphFilePath, gqs.srcDataGraph, gqs.objDataGraph, gqs.edgeType, gqs.nodeTypes, loadDataGraph);
			//dg.loadDataGraph(dataGraphFilePath, gqs.srcDataGraph, gqs.objDataGraph, gqs.edgeType, gqs.nodeTypes);
			System.out.println("populating the inverted node type info");
			gqs.populateInvertedNodeType();
			if(gqs.concatenateIntermediatNodeEdges) {
				System.out.println("Populating intermediate nodes");
				lfm.loadIntermediateNodesList(gqs.conf.getInputFilePath(PropertyKeys.intermediateNodesFile), gqs.intermediateNodesList);
				System.out.println("loading the concatenated property mapping list");
				lfm.loadConcatedPropertiesList(gqs.conf.getOutputFilePath(PropertyKeys.barcelonaToFreebaseNewConcatenatedPropertiesFile),
						gqs.concatenatedEdgesToNewEdgeIdMap);
			}
		}
		else {
			//dg.loadDataGraph(dataGraphFilePath, gqs.srcDataGraph, gqs.objDataGraph);
		}
		System.out.println("Done loading data graph");
		File inputQueryFiles = new File(gqs.conf.getInputFilePath(PropertyKeys.testPartialAndTargetQueryFiles));

		// create buffered random access file handlers
		try {
			gqs.sourceDataGraphFileHandler = new BufferedRandomAccessFile(gqs.conf.getInputFilePath(PropertyKeys.datagraphSourceAlignedFile), "r", gqs.numOfTotalEdges, gqs.conf);
			gqs.objectDataGraphFileHandler = new BufferedRandomAccessFile(gqs.conf.getInputFilePath(PropertyKeys.datagraphObjectAlignedFile), "r", gqs.numOfTotalEdges, gqs.conf);
			gqs.queryCompletor(inputQueryFiles);
			gqs.sourceDataGraphFileHandler.close();
			gqs.objectDataGraphFileHandler.close();
		} catch(IOException ioe) {
			ioe.printStackTrace();
		}
		System.out.println("Done with completing all queries!!!");
	}

	private void loadEdgeTypeInfo() {
		int datasetFlag = Integer.parseInt(conf.getProp(PropertyKeys.datasetFlag));
		if(datasetFlag == 0)
			isFreebaseDataset = true;
		if(isFreebaseDataset) {
			gqhelper.loadEdgeTypeInfo(conf.getInputFilePath(PropertyKeys.edgeTypeFile), edgeType, srcTypeEdges, objTypeEdges);
		}
	}

	private void populateInvertedNodeType() {
		Iterator<Integer> iter = nodeTypes.keySet().iterator();
		while(iter.hasNext()) {
			HashSet<Integer> types = nodeTypes.get(iter.next());
			// add every node-type in "types" as relevant type to every other node.
			int len = types.size();
			int[] typesarr = new int[len];
			Iterator<Integer> it = types.iterator();
			int i = 0;
			while(it.hasNext()) {
				typesarr[i] = it.next();
				i++;
			}
			for(int j=0; j<len-1; j++) {
				int t1 = typesarr[j];
				HashSet<Integer> t1type;
				if(invertedNodeTypes.containsKey(t1)) {
					t1type = invertedNodeTypes.get(t1);
				}
				else {
					t1type = new HashSet<Integer>();
				}
				for(int k=j+1; k<len; k++) {
					int t2 = typesarr[k];
					t1type.add(t2);

					// add t1 as a type relevant to type t2.
					HashSet<Integer> t2type;
					if(invertedNodeTypes.containsKey(t2)) {
						t2type = invertedNodeTypes.get(t2);
						t2type.add(t1);
					}
					else {
						t2type = new HashSet<Integer>();
						t2type.add(t1);
						invertedNodeTypes.put(t2, t2type);
					}
				}
				if(!invertedNodeTypes.containsKey(t1))
					invertedNodeTypes.put(t1, t1type);
			}
		}
	}

	private void queryCompletor(File inputFilesFolder) {
		model = gqhelper.getModelToUseForType(Integer.parseInt(conf.getProp(PropertyKeys.modelToUse)));
		/*try {
			System.out.println("before learning model");
			System.in.read();
		}
		catch(Exception e) {
			e.printStackTrace();
		}*/
		learnModel();
		/*try {
			System.out.println("after learning model");
			System.in.read();
		}
		catch(Exception e) {
			e.printStackTrace();
		}*/
		if(Integer.parseInt(conf.getProp(PropertyKeys.ignoreNegativeEdges)) == 0) {
			ignoreNegativeEdgesInHistory = true;
		}
		String outQueryFilesFolder = conf.getOutputFilePath(PropertyKeys.edgeSuggestionOutputFolder);
		File[] listOfInputQueryFiles = inputFilesFolder.listFiles();
		for(int i=0; i<listOfInputQueryFiles.length; i++) {
			// Each file must contain the partial query graph and the target query graph.
			if(listOfInputQueryFiles[i].isFile()) {
				String outFileName = listOfInputQueryFiles[i].getName();
				System.out.println("Starting query completion for file " + outFileName);
				String inputQueryFilePath = listOfInputQueryFiles[i].getAbsolutePath();
				/*
				 * This graph representation stores the input graph and the target graph (which is to be used in prototype). In the actual
				 * system, we are unaware of the targetGraph, only the user knows it.
				 * key = edge ID
				 * value = edge ends (src, obj)
				 *
				 * NOTE: If, a key has "null" as its value, it means the key represents an Vertex ID.
				 * if value = null,
				 * key = vertex ID.
				 *
				 * The null case is not supposed to occur in the target graph. The target graph MUST be connected.
				 */
				HashMap<Integer, HashMap<Integer, ArrayList<DestNode>>> partialGraph = new HashMap<Integer, HashMap<Integer, ArrayList<DestNode>>>();
				HashMap<Integer, HashMap<Integer, ArrayList<DestNode>>> targetGraph = new HashMap<Integer, HashMap<Integer, ArrayList<DestNode>>>();
				// put in the set of anchor nodes.
				HashSet<Integer> anchorNodes = new HashSet<Integer>();
				ArrayList<HashMap<Integer, HashMap<Integer, ArrayList<DestNode>>>> allPartialGraphs = gqhelper.readInputQueryFile(inputQueryFilePath, partialGraph, targetGraph, anchorNodes);
				ArrayList<HashMap<Integer, HashMap<Integer, ArrayList<DestNode>>>> allTargetGraphs = makeDeepCopies(targetGraph, allPartialGraphs.size());
				for(int j=0; j<allPartialGraphs.size(); j++) {
					String outputTargetQueryFilePath = outQueryFilesFolder + outFileName + "-" + j;
					long startTime = java.lang.System.currentTimeMillis();
					makeEdgeSuggestions(allPartialGraphs.get(j), allTargetGraphs.get(j), anchorNodes);
					long endTime = java.lang.System.currentTimeMillis();
					System.out.println("Time taken for completing this graph (in ms) = " + (endTime - startTime));
					gqhelper.printConstructedGraph(allPartialGraphs.get(j), outputTargetQueryFilePath);
					System.out.println("COMPLETED query completion for file " + outFileName);
				}
			}
		}
	}

	private ArrayList<HashMap<Integer, HashMap<Integer, ArrayList<DestNode>>>> makeDeepCopies(
			HashMap<Integer, HashMap<Integer, ArrayList<DestNode>>> targetGraph, int numOfCopies) {
		ArrayList<HashMap<Integer, HashMap<Integer, ArrayList<DestNode>>>> allCopies =
				new ArrayList<HashMap<Integer,HashMap<Integer,ArrayList<DestNode>>>>();
		for(int i=0; i<numOfCopies; i++) {
			HashMap<Integer, HashMap<Integer, ArrayList<DestNode>>> tg = new HashMap<Integer, HashMap<Integer,ArrayList<DestNode>>>();
			Iterator<Integer> iter1 = targetGraph.keySet().iterator();
			while(iter1.hasNext()) {
				int vertex = iter1.next();
				HashMap<Integer, ArrayList<DestNode>> propDest = targetGraph.get(vertex);
				HashMap<Integer, ArrayList<DestNode>> newPropDest = new HashMap<Integer, ArrayList<DestNode>>();

				Iterator<Integer> iter2 = propDest.keySet().iterator();
				while(iter2.hasNext()) {
					int edge = iter2.next();
					ArrayList<DestNode> destnodes = propDest.get(edge);
					ArrayList<DestNode> newDestNodes = new ArrayList<DestNode>();

					for(DestNode dn : destnodes) {
						DestNode newDn = new DestNode();
						newDn.setDest(dn.getDest());
						newDn.setForwardEdge(dn.isForwardEdge());
						newDestNodes.add(newDn);
					}
					newPropDest.put(edge, newDestNodes);
				}
				tg.put(vertex, newPropDest);
			}
			allCopies.add(tg);
		}
		return allCopies;
	}

	private void makeEdgeSuggestions(HashMap<Integer, HashMap<Integer, ArrayList<DestNode>>> partialGraph,
			HashMap<Integer, HashMap<Integer, ArrayList<DestNode>>> targetGraph, HashSet<Integer> anchorNodes) {
		//System.out.println("inside make suggestions");
		/*try {
			System.in.read();
		}
		catch(Exception e) {
			e.printStackTrace();
		}*/
		// contains the candidate graph, which is changed after every edge suggestion. We will delete an edge if is accepted (but added
		// into the partial graph). Edges are only deleted if it is rejected.
		// Note that, all edges of the same label are deleted from the candidate graph (assuming a yes or no is said to all edges
		// that are incident on the partial graph, which is the current instance of the candidate graph.
		// key = edge, value = <src, obj, tupleID>
		HashMap<Integer, ArrayList<EdgeEnds>> candidateGraph = new HashMap<Integer, ArrayList<EdgeEnds>>();
		HashSet<Integer> candidateEdges = new HashSet<Integer>();
		ArrayList<Integer> history = new ArrayList<Integer>();
		// this contains the tuple IDs seen so far. This includes both the ones present in the partial graph and those rejected too.
		HashSet<MutableString> seenTuples = new HashSet<MutableString>();

		initializeHistorySeenTuplesListAndTargetGraph(history, seenTuples, partialGraph, targetGraph);
		initializeCandidateEdges(candidateGraph, partialGraph, candidateEdges, seenTuples);

		int numOfSuggestionsThreshold = Integer.parseInt(conf.getProp(PropertyKeys.NumberOfSuggestionsThreshold));
		int numOfSuggestions = 0;
		int numOfNegs = 0;
		HashSet<Integer> correctSuggestions = new HashSet<Integer>();
		while(numOfSuggestions < numOfSuggestionsThreshold && !candidateEdges.isEmpty() && !targetGraph.isEmpty()) {
			//logger.debug("Cand edges = " + candidateEdges.size());
			/*System.out.println("-==============================-");
			System.out.println("-================================-");
			for(int i=0; i<history.size(); i++) {
				System.out.println(history.get(i));
			}
			System.out.println("-==============================-");
			System.out.println("-================================-");*/
			/*try {
				System.out.println("before call to dec forest");
				System.in.read();
			}
			catch(Exception e) {
				e.printStackTrace();
			}*/
			int suggestedEdge = findBestEdge(history, candidateEdges);
			/*System.out.println("done finding best edge");
			try {
				System.in.read();
			}
			catch(Exception e) {
				e.printStackTrace();
			}*/
	//		System.out.println("candidates = " + candidateEdges.size());

			if(suggestedEdge == 0) {
				//System.out.println("Suggested edge was a 0.. breaking out..");
//				logger.warn("There was no edge in candidateEdges??");
				suggestedEdge = RandomEdgeSuggestor.getRandomEdge(candidateEdges);
				//System.out.println(suggestedEdge);
				//break;
			}
			candidateEdges.remove(suggestedEdge);
			int prop = suggestedEdge;
	//		boolean previouslyAcceptedNowRejectedEdge = false;
			ArrayList<EdgeEnds> positiveEdges = null;
			if((positiveEdges = isPositiveSuggestedEdge(suggestedEdge, partialGraph, targetGraph)) != null) {
				if(partialGraph.isEmpty()) {
					// The input query graph was empty and this was the first edge to be accepted. Start over with the candidates.
					// if there is even a single edge in the partial query graph, it means candidate edges list will be appended to.
					candidateEdges.clear();
				}
				gqhelper.addEdgesToPartialGraph(suggestedEdge, positiveEdges, partialGraph);
				gqhelper.removeEdgesFromTargetGraph(suggestedEdge, positiveEdges, targetGraph);
				correctSuggestions.add(prop);
			}
			else {
			//	if(correctSuggestions.contains(prop))
			//		previouslyAcceptedNowRejectedEdge = true;
				prop = prop*(-1);
			}
			// add all the tuple IDs in candidate graph corresponding to a given edge label to seenTupleIDs.
			// remove all the instances of the suggested edge from candidate graph.
			updateSeenTupleIDsListAndCandidateGraph(seenTuples, suggestedEdge, candidateGraph);

			if(prop > 0) {
				// this means that the newly suggested edge was accepted. So we may get to add new candidate edges.
				findNewCandidateEdges(suggestedEdge, candidateGraph, positiveEdges, candidateEdges, seenTuples);
			}

			if(prop < 0) {
				numOfNegs++;
//				logger.debug("---> " + suggestedEdge + " ----- > NEG");
			}
			else {
//				logger.debug("cand edges remaining = " + candidateEdges.size() + ", negs suggested = " +
//			numOfNegs + " ---> " + suggestedEdge + " ----- > POSITIVEEEEEEE");
				numOfNegs = 0;
			}

			// add the suggested edge to history only if its not already present in the history,
			// AND, if this edge was rejected, add it iff it was not accepted in a previous iteration.
			boolean addEdgeToHistory = true;
			if(ignoreNegativeEdgesInHistory) {
				if(prop < 0)
					addEdgeToHistory = false;
			}
			else {
				int posProp = prop;
				if(prop < 0)
					posProp = prop*(-1);
				for(int i=0; i<history.size(); i++) {
					// do not add edge, if the accepted version of THIS rejected edge was already in the hisory.
					// do not add edge, if the same edge was rejected earlier too.
					if(history.get(i) == posProp || history.get(i) == prop) {
						addEdgeToHistory = false;
						break;
					}
				}
			}
			if(addEdgeToHistory)
				history.add(prop);
			//if(!previouslyAcceptedNowRejectedEdge)
			//	history.add(prop);
			numOfSuggestions++;
			//System.out.println("done updating DS after edge suggestion");
			/*try {
				System.in.read();
			}
			catch(Exception e) {
				e.printStackTrace();
			}*/
		}
		System.out.println("NUMBER of SUGGESTIONS MADE : " + numOfSuggestions);
//		logger.info("NUMBER of SUGGESTIONS MADE : " + numOfSuggestions);
		if(numOfSuggestions == numOfSuggestionsThreshold) {
			System.out.println("100 suggestions up!!!!!!!!!");
//			logger.error("100 suggestions up!!!!!!!!!");
		}
	}

	private void findNewCandidateEdges(int prop, HashMap<Integer, ArrayList<EdgeEnds>> candidateGraph,
			ArrayList<EdgeEnds> positiveEdges, HashSet<Integer> candidateEdges, HashSet<MutableString> seenTuples) {
		// in this method, add all new edges that come into candidateGraph due to the addition of positiveEdges into the
		// partial graph.
		// fist construct a pseudo-partial graph that consists of only edges present in partial graph,
		// and input this to initializeCandidateEdges method. that should find all new edges that come in candidateGraph due to the
		// new edges found in positiveEdges.
		HashMap<Integer, HashMap<Integer, ArrayList<DestNode>>> pseudoPartialGraph = new HashMap<Integer, HashMap<Integer,ArrayList<DestNode>>>();
		gqhelper.addEdgesToPartialGraph(prop, positiveEdges, pseudoPartialGraph);
		initializeCandidateEdges(candidateGraph, pseudoPartialGraph, candidateEdges, seenTuples);
	}

	private void initializeCandidateEdges(HashMap<Integer, ArrayList<EdgeEnds>> candidateGraph,
			HashMap<Integer, HashMap<Integer, ArrayList<DestNode>>> partialGraph,
			HashSet<Integer> candidateEdges, HashSet<MutableString> seenTuples) {
		// for every node present in the initial partial graph, add the neighboring edges (not in the partial graph) to the candidate
		// graph. also add these edges to candidate edges list.
		HashSet<MutableString> addedTuples = new HashSet<MutableString>();
		if(partialGraph.isEmpty()) {
			// The input could be empty. All edges are candidate edges.
			if(candidateEdges.isEmpty()) {
				// this is the first time we are even coming to this method. just populate all edges into candidate edges, until we
				// hit at least one positive edge suggestion.
				// if this is not the first time we have come in here, then the set of candidate edges is already populated.
				// the just suggested edge was also removed.
				Iterator<Integer> iter = edgeType.keySet().iterator();
				while(iter.hasNext()) {
					candidateEdges.add(iter.next());
				}
			}
		}
		else {
			Iterator<Integer> iter = partialGraph.keySet().iterator();
			while(iter.hasNext()) {
				int vertex = iter.next();
				if((srcTypeEdges.containsKey(vertex) || objTypeEdges.containsKey(vertex))) {
					// if this vertex is a type node associated with an intermediate node, don't bother adding anything.
					/*if(isFreebaseDataset && intermediateNodesTypeList.contains(vertex))
						continue;*/
					// This vertex is a type node.
					addTypeBasedEdges(addedTuples, vertex, vertex, candidateGraph, candidateEdges, partialGraph.get(vertex));
					HashSet<Integer> types = invertedNodeTypes.get(vertex);
					if(types != null) {
						Iterator<Integer> typesIter = types.iterator();
						while(typesIter.hasNext()) {
							int type = typesIter.next();
							// the edgeType_relation file will contain information regarding the types of ends of a newly created edge
							// that has replaced the concatenated edge. so we will eventually hit it.
							/*if(isFreebaseDataset && intermediateNodesTypeList.contains(type))
								continue;*/
							addTypeBasedEdges(addedTuples, vertex, type, candidateGraph, candidateEdges, partialGraph.get(vertex));
						}
					}
				}
				else {
					// if this vertex is an intermediate node, don't bother adding anything.
					if(isFreebaseDataset && intermediateNodesList.contains(vertex))
						continue;
				//	HashSet<Integer> addedEdges = new HashSet<Integer>();
					// this vertex is an actual node from the data graph.
					// add all those edges where vertex is the source...
					//ArrayList<ObjNodeIntProperty> ons = srcDataGraph.get(vertex);
					ArrayList<ObjNodeIntProperty> ons = sourceDataGraphFileHandler.getVertexNeighbors(vertex);
					if(ons != null) {
						getCandidateEdge(candidateGraph, candidateEdges, seenTuples, addedTuples, vertex, ons);
					}
					// add all those edges where vertex is the object...
					//logger.debug("neighbors of vertex " + vertex);
					//ArrayList<ObjNodeIntProperty> revons = objDataGraph.get(vertex);
					ArrayList<ObjNodeIntProperty> revons = objectDataGraphFileHandler.getVertexNeighbors(vertex);
					if(revons != null) {
						getCandidateEdge(candidateGraph, candidateEdges, seenTuples, addedTuples, vertex, revons);
						/*for(ObjNodeIntProperty on : revons) {
							if(isFreebaseDataset && intermediateNodesList.contains(on.dest)) {
								// get other nodes connected to this intermediate node.
								concatenateEdgesAndAddProp(candidateGraph, candidateEdges, seenTuples, addedTuples, vertex, on);
							}
							else {
								MutableString tid = getTupleID(vertex, on.prop, on.dest);
								if(!addedTuples.contains(tid) && !seenTuples.contains(tid)) {
								//	addedEdges.add(on.prop);
									EdgeEnds ee = new EdgeEnds();
									ee.source = on.dest;
									ee.object = vertex;
									addToCandidateGraph(candidateGraph, candidateEdges, addedTuples, on.prop, ee, tid);
								}
							}
						}*/
					}

					/*// NOW add edges that are NOT incident on this exact vertex, BUT edges that may be incident on this vertex's types.
					HashSet<Integer> types = nodeTypes.get(vertex);
					Iterator<Integer> typesIter = types.iterator();
					while(typesIter.hasNext()) {
						int type = typesIter.next();
						addTypeBasedEdges(addedTuples, seenTuples, type, candidateGraph, candidateEdges, vertex);
					}*/
				}
			}
		}
	}

	private void getCandidateEdge(HashMap<Integer, ArrayList<EdgeEnds>> candidateGraph,
			HashSet<Integer> candidateEdges, HashSet<MutableString> seenTuples,
			HashSet<MutableString> addedTuples, int vertex, ArrayList<ObjNodeIntProperty> ons) {
		for(ObjNodeIntProperty on : ons) {
			if(isFreebaseDataset && intermediateNodesList.contains(on.dest)) {
				// get other nodes connected to this intermediate node.
				concatenateEdgesAndAddProp(candidateGraph, candidateEdges, seenTuples, addedTuples, vertex, on);
			}
			else {
				MutableString tid = getTupleID(vertex, on.prop, on.dest);
				if(!addedTuples.contains(tid) && !seenTuples.contains(tid)) {
				//	addedEdges.add(on.prop);
					EdgeEnds ee = new EdgeEnds();
					ee.source = vertex;
					ee.object = on.dest;
					addToCandidateGraph(candidateGraph, candidateEdges, addedTuples, on.prop, ee, tid);
				}
			}
		}
	}

	private void concatenateEdgesAndAddProp(HashMap<Integer, ArrayList<EdgeEnds>> candidateGraph,
			HashSet<Integer> candidateEdges, HashSet<MutableString> seenTuples,
			HashSet<MutableString> addedTuples, int vertex, ObjNodeIntProperty on) {
		ArrayList<IntermediateNodeAndOtherEnd> intermediateEdges = getOtherEdgesOnIntermediateNode(vertex, on.prop, on.dest);
		for(IntermediateNodeAndOtherEnd interEdge : intermediateEdges) {
			String concatEdge = "";
			if(on.prop < interEdge.prop)
				concatEdge = on.prop + "," + interEdge.prop;
			else
				concatEdge = interEdge.prop + "," + on.prop;
			if(!concatenatedEdgesToNewEdgeIdMap.containsKey(concatEdge)) {
				// we have never seen this occurrence in our list. so ignore this.
				continue;
			}
			int newEdgeId = concatenatedEdgesToNewEdgeIdMap.get(concatEdge);
			MutableString tid = getTupleID(vertex, newEdgeId, interEdge.node);
			if(!addedTuples.contains(tid) && !seenTuples.contains(tid)) {
				EdgeEnds ee = new EdgeEnds();
				if(on.prop < interEdge.prop) {
					ee.source = vertex;
					ee.object = interEdge.node;
				}
				else {
					ee.source = interEdge.node;
					ee.object = vertex;
				}
				addToCandidateGraph(candidateGraph, candidateEdges, addedTuples, newEdgeId, ee, tid);
			}
		}
	}

	private ArrayList<IntermediateNodeAndOtherEnd> getOtherEdgesOnIntermediateNode(int firstNode, int firstProp, int intermediateNode) {
		ArrayList<IntermediateNodeAndOtherEnd> intermediateEdges = new ArrayList<IntermediateNodeAndOtherEnd>();
		if(srcDataGraph.containsKey(intermediateNode))
		{
			ArrayList<ObjNodeIntProperty> objList = srcDataGraph.get(intermediateNode);
			for(ObjNodeIntProperty on : objList) {
				if(on.prop != firstProp) {
					IntermediateNodeAndOtherEnd ina = new IntermediateNodeAndOtherEnd();
					ina.node = on.dest;
					ina.prop = on.prop;
					intermediateEdges.add(ina);
				}
			}
		}
		if(objDataGraph.containsKey(intermediateNode))
		{
			ArrayList<ObjNodeIntProperty> objList = objDataGraph.get(intermediateNode);
			for(ObjNodeIntProperty on : objList) {
				if(on.prop != firstProp) {
					IntermediateNodeAndOtherEnd ina = new IntermediateNodeAndOtherEnd();
					ina.node = on.dest;
					ina.prop = on.prop;
					intermediateEdges.add(ina);
				}
			}
		}
		return intermediateEdges;
	}

	/*private void addTypeBasedEdges(HashSet<MutableString> addedTuples, HashSet<MutableString> seenTuples, int type,
			HashMap<Integer, ArrayList<EdgeEnds>> candidateGraph, HashSet<Integer> candidateEdges, int actualVertex) {
		// edges incident on this node type being source.
		if(srcTypeEdges.containsKey(type)) {
			HashSet<Integer> edgeList = srcTypeEdges.get(type);
			Iterator<Integer> iter = edgeList.iterator();
			while(iter.hasNext()) {
				int edge = iter.next();
				addTypeEdge(addedTuples, seenTuples, candidateGraph, candidateEdges, edge, actualVertex, true);
			}
		}
		// edges incident on this node type being object.
		if(objTypeEdges.containsKey(type)) {
			HashSet<Integer> edgeList = objTypeEdges.get(type);
			Iterator<Integer> iter = edgeList.iterator();
			while(iter.hasNext()) {
				int edge = iter.next();
				addTypeEdge(addedTuples, seenTuples, candidateGraph, candidateEdges, edge, actualVertex, false);
			}
		}
	}*/

	/*private void addTypeEdge(HashSet<MutableString> addedTuples, HashSet<MutableString> seenTuples,
			HashMap<Integer, ArrayList<EdgeEnds>> candidateGraph, HashSet<Integer> candidateEdges,
			int edge, int actualVertex, boolean edgeDirectionForward) {
		EdgeTypeInfo eti = edgeType.get(edge);
		MutableString tid = getTupleID(eti.source_type, edge, eti.object_type);
		if(!addedTuples.contains(tid) && !seenTuples.contains(tid)) {
			EdgeEnds ee = new EdgeEnds();
			if(edgeDirectionForward) {
				ee.source = actualVertex;
				ee.object = eti.object_type;
			}
			else {
				ee.source = eti.source_type;
				ee.object = actualVertex;
			}
			addToCandidateGraph(candidateGraph, candidateEdges, addedTuples, edge, ee, tid);
		}
	}*/

	private void addTypeBasedEdges(HashSet<MutableString> addedTuples, int actualType, int type,
			HashMap<Integer, ArrayList<EdgeEnds>> candidateGraph, HashSet<Integer> candidateEdges,
			HashMap<Integer, ArrayList<DestNode>> actualTypeIncidentEdgeList) {
		/*
		 * The problem with both ends of the node being a TYPE and not an instance (actual node in the data graph) is that
		 * the signature in "seenTuple" does not identify something unique. An edge that was suggested early on, but was rejected
		 * because it was not what the user was looking for at that particular partial graph instance, cannot be suggested again
		 * because "seenTuples" will preclude that from happening.
		 * So, we do not check if this type-prop-type signature is in "seenTuples" or not. We add it anyway.
		 */
		// edges incident on this node type being source.
		if(srcTypeEdges.containsKey(type)) {
			HashSet<Integer> edgeList = srcTypeEdges.get(type);
			Iterator<Integer> iter = edgeList.iterator();
			while(iter.hasNext()) {
				int edge = iter.next();
				if(edgeLeadsToIntermediateConcatenation(edge, actualTypeIncidentEdgeList))
					continue;
				addTypeEdge(addedTuples, candidateGraph, candidateEdges, edge, actualType, type);
			}
		}
		// edges incident on this node type being object.
		if(objTypeEdges.containsKey(type)) {
			HashSet<Integer> edgeList = objTypeEdges.get(type);
			Iterator<Integer> iter = edgeList.iterator();
			while(iter.hasNext()) {
				int edge = iter.next();
				if(edgeLeadsToIntermediateConcatenation(edge, actualTypeIncidentEdgeList))
					continue;
				addTypeEdge(addedTuples, candidateGraph, candidateEdges, edge, actualType, type);
			}
		}
	}

	/**
	 * Look at the existing edges incident on the actualType (this is the node in the partial graph). If any of these edges, when concatenated
	 * with the newly found edge newEdge leads to a concatenated intermediate edge, then we must ignore it.
	 * @param newEdge
	 * @param actualTypeIncidentEdgeList
	 * @return
	 */
	private boolean edgeLeadsToIntermediateConcatenation(int newEdge, HashMap<Integer, ArrayList<DestNode>> actualTypeIncidentEdgeList) {
		boolean formsConcatenatedEdge = false;
		if(concatenateIntermediatNodeEdges) {
			Iterator<Integer> iter = actualTypeIncidentEdgeList.keySet().iterator();
			while(iter.hasNext()) {
				int edge = iter.next();
				String concatEdge;
				if(edge < newEdge)
					concatEdge = edge + "," + newEdge;
				else
					concatEdge = newEdge + "," + edge;
				if(concatenatedEdgesToNewEdgeIdMap.containsKey(concatEdge)) {
					formsConcatenatedEdge = true;
					break;
				}
			}
		}
		return formsConcatenatedEdge;
	}

	private void addTypeEdge(HashSet<MutableString> addedTuples, HashMap<Integer, ArrayList<EdgeEnds>> candidateGraph,
			HashSet<Integer> candidateEdges, int edge, int actualType, int type) {
		EdgeTypeInfo eti = edgeType.get(edge);
		int srctype = eti.source_type;
		int objtype = eti.object_type;
		if(srctype == type)
			srctype = actualType;
		else
			objtype = actualType;
		MutableString tid = getTupleID(srctype, edge, objtype);
		if(!addedTuples.contains(tid)) {
			EdgeEnds ee = new EdgeEnds();
			ee.source = eti.source_type;
			ee.object = eti.object_type;
			addToCandidateGraph(candidateGraph, candidateEdges, addedTuples, edge, ee, tid);
		}
	}

	private void addToCandidateGraph(HashMap<Integer, ArrayList<EdgeEnds>> candidateGraph, HashSet<Integer> candidateEdges,
			HashSet<MutableString> addedTuples, int prop, EdgeEnds ee, MutableString tid) {
		candidateEdges.add(prop);
		addedTuples.add(tid);
		ArrayList<EdgeEnds> edges;
		if(candidateGraph.containsKey(prop)) {
			edges = candidateGraph.get(prop);
			edges.add(ee);
		}
		else {
			edges = new ArrayList<EdgeEnds>();
			edges.add(ee);
		}
		candidateGraph.put(prop, edges);
	}

	private void initializeHistorySeenTuplesListAndTargetGraph(ArrayList<Integer> history, HashSet<MutableString> seenTuples,
			HashMap<Integer, HashMap<Integer, ArrayList<DestNode>>> partialGraph,
			HashMap<Integer, HashMap<Integer, ArrayList<DestNode>>> targetGraph) {
		// look at the initial partial graph and add edges present in it to seenTuples.
		// also add it to the history.
		// if there are no edges in the partial query graph (only nodes), then seentuples and history are empty.
		// the edges found in the partial graph must be removed from the target graph.
		Iterator<Integer> iter = partialGraph.keySet().iterator();
		HashSet<Integer> seenProps = new HashSet<Integer>();
		while(iter.hasNext()) {
			int src = iter.next();
			HashMap<Integer, ArrayList<DestNode>> propDest = partialGraph.get(src);
			if(propDest != null) {
				Iterator<Integer> iter1 = propDest.keySet().iterator();
				while(iter1.hasNext()) {
					int prop = iter1.next();
					if(!seenProps.contains(prop)) {
						history.add(prop);
						seenProps.add(prop);
					}
					ArrayList<DestNode> dns = propDest.get(prop);
					for(DestNode dn : dns) {
						if(dn.isForwardEdge()) {
							seenTuples.add(getTupleID(src, prop, dn.getDest()));
							removeInitialEdgesFromTargetGraph(src, prop, dn.getDest(), targetGraph);
						}
					}
				}
			}
		}
	}

	private void removeInitialEdgesFromTargetGraph(int src, int prop, int dest,
			HashMap<Integer, HashMap<Integer, ArrayList<DestNode>>> targetGraph) {
		gqhelper.removeEdge(src, prop, dest, targetGraph);
		gqhelper.removeEdge(dest, prop, src, targetGraph);
	}

	private MutableString getTupleID(int src, int prop, int dest) {
		 MutableString tid = new MutableString();
		if(src < dest) {
			tid = tid.append(src).append(",").append(prop).append(",").append(dest);
		}
		else {
			tid = tid.append(dest).append(",").append(prop).append(",").append(src);
		}
		return tid;
	}

	private ArrayList<EdgeEnds> isPositiveSuggestedEdge(int suggestedEdge, HashMap<Integer, HashMap<Integer, ArrayList<DestNode>>> partialGraph,
			HashMap<Integer, HashMap<Integer, ArrayList<DestNode>>> targetGraph) {
		// NOTE: the existence of the edge is a little loose here. A vertex can be connected to multiple instances of an edge label.
		// so if there is an edge say (a_1 -> e_1 -> a_2) in the target graph, and we have made the following suggestion (a_1 -> e_1 -> b_2)
		// then I would still say it is valid, and correct the suggested edge to the exact one in the target graph.
		// REASON to do this: If there are multiple instances of an edge associated with the same vertex, instead of making individual
		// suggestion to each of those instances, we can assume that given an edge associated with that vertex, we can expect the user
		// to identify the correct target node.
		ArrayList<EdgeEnds> positiveEdges = null;
		HashSet<MutableString> addedTuples = new HashSet<MutableString>();
		Iterator<Integer> iter = partialGraph.keySet().iterator();
		while(iter.hasNext()) {
			int v = iter.next();
			if(targetGraph.containsKey(v)) {
				HashMap<Integer, ArrayList<DestNode>> propDest = targetGraph.get(v);
				if(propDest.containsKey(suggestedEdge)) {
					ArrayList<DestNode> dns = propDest.get(suggestedEdge);
					for(DestNode dn : dns) {
						int src;
						int dest;
						if(dn.isForwardEdge()) {
							src = v;
							dest = dn.getDest();
						}
						else {
							src = dn.getDest();
							dest = v;
						}
						MutableString tupleID = getTupleID(src, suggestedEdge, dest);
						if(!addedTuples.contains(tupleID)) {
							addedTuples.add(tupleID);
							if(positiveEdges == null) {
								positiveEdges = new ArrayList<EdgeEnds>();
							}
							EdgeEnds ee = new EdgeEnds();
							ee.source = src;
							ee.object = dest;
							//ee.tupleID = tupleID;
							positiveEdges.add(ee);
						}
					}
				}
			}
		}
		return positiveEdges;
	}

	private void updateSeenTupleIDsListAndCandidateGraph(HashSet<MutableString> seenTuples, int prop,
			HashMap<Integer, ArrayList<EdgeEnds>> candidateGraph) {
		// add the newly added tuple IDs into seentuples list.
		// remove the entries associated with "prop" from candidateGraph.
		//System.out.println(prop);
		ArrayList<EdgeEnds> props = candidateGraph.get(prop);
		if(props != null) {
			for(EdgeEnds ee : props) {
				seenTuples.add(getTupleID(ee.source, prop, ee.object));
			}
			candidateGraph.remove(prop);
		}
	}

	private void learnModel() {
	    //0 = DecisionForest;	1 = Random Forests;	2 = Naive Bayesian model;	3 = Random edge suggestion;
		//4 = recommendation systems (SVD);	5 = RandomSubsets;	6 = SVM;	7 = MEMM model;
		//enum ModelToUseForType {DF, RF, NBC, RAND, SVD, RandSubsts, SVM, MEMM};
		switch(model) {
		case DF:
			dfm = new DecisionForestMain(conf);
			System.out.println("Learning model DECISON FOREST");
//			logger.info("Learning model DECISON FOREST");
			//dfm.learnModel();
			break;
		case RF:
			rfp = new RandomForestPredict();
			System.out.println("Learning model Random FOREST");
//			logger.info("Learning model Random FOREST");
			rfp.learnModel();
			break;
		case NBC:
			nbc = new NaiveBayesianMain(conf);
			System.out.println("Learning model Naive BAYESIAN");
//			logger.info("Learning model Naive BAYESIAN");
			nbc.learnModel();
			break;
		case RAND:
			res = new RandomEdgeSuggestor(conf);
			System.out.println("Learning model RANDOM crazy");
//			logger.info("Learning model RANDOM crazy");
			res.learnModel();
			break;
			// do things.
		case SVD:
			svd = new RecommendationSystem();
			System.out.println("Learning model SVD based recommendation system");
//			logger.info("Learning model SVD based recommendation system");
			svd.learnModel();
			break;
		case RandSubsets:
			rsm = new RandomSubsetsMain(conf);
			System.out.println("Learning model random subsets");
//			logger.info("Learning model random subsets");
			rsm.learnModel();
			break;
		case SVM:
			System.out.println("Learning model SVM");
//			logger.info("Learning model SVM");
			break;
			// do things.
		case MEMM:
			System.out.println("Learning model RANDOM FOREST");
//			logger.info("Learning model RANDOM FOREST");
			break;
			// do things.
		}

	}

	private int findBestEdge(ArrayList<Integer> history, HashSet<Integer> candidateEdges) {
	    //0 = DecisionForest;	1 = Random Forests;	2 = Naive Bayesian model;	3 = Random edge suggestion;
		//4 = recommendation systems (SVD);	5 = RandomSubsets;	6 = SVM;	7 = MEMM model;
		//enum ModelToUseForType {DF, RF, NBC, RAND, SVD, RandSubsets, SVM, MEMM};
		int bestEdge = -1;
		switch(model) {
		case DF:
			//bestEdge = dfm.findBestEdge(history, candidateEdges);
			break;
		case RF:
			bestEdge = rfp.findBestEdge(history, candidateEdges);
			break;
		case NBC:
			bestEdge = nbc.findBestEdge(history, candidateEdges);
			break;
		case RAND:
			bestEdge = RandomEdgeSuggestor.getRandomEdge(candidateEdges);
			break;
		case SVD:
			bestEdge = svd.findBestEdge(history, candidateEdges);
			break;
		case RandSubsets:
			bestEdge = rsm.findBestEdge(history, candidateEdges);
			break;
		case SVM:
			// do things.
		case MEMM:
			// do things.
		}
		return bestEdge;
	}
}

/*final class IntermediateNodeAndOtherEnd {
	int prop;
	int node;
}*/
